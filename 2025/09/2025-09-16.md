# 2025-09-16 TIL

# ✅ 오늘 한 일
- 그래프 최소 비용 주제 정리: **MST(Prim, Kruskal)** + **최단 경로(Dijkstra)** 개념·구현 복습
- 인접 행렬 vs 인접 리스트 선택 기준과 시간복잡도 비교
- 우선순위 큐(힙)와 Union-Find(경로 압축 + 랭크) 재점검

# 📚 배운 점
- **신장 트리**: 무방향 그래프에서 모든 정점을 포함하고 간선이 N-1개인 트리
- **MST**: 모든 정점을 연결하는 간선 가중치 합의 최소. (가중치가 모두 서로 다르면 MST는 유일)
- **Prim vs Kruskal**
  - Prim: 정점 중심으로 **한 그래프에서** 시작 → 인접 최소 간선 확장 (우선순위 큐)
  - Kruskal: **간선 전체 정렬** 후 사이클 없게 선택 (Union-Find)
- **Dijkstra**: 음수 간선 없을 때, 시작점에서 각 정점까지의 최단 거리. MST의 Prim과 그리디 구조가 유사하나 목적이 다름.
- **자료구조 선택**
  - 희소 그래프 → 인접 리스트 + 힙: `O(E log V)`
  - 조밀 그래프 → 인접 행렬 + 단순 선택: `O(V^2)`

# 📌 핵심 개념
- **컷/사이클 속성**
  - 컷을 가로지르는 가장 작은 간선은 MST에 포함(Prim의 안전 간선 원리)
  - 사이클에서 가장 큰 간선은 MST에 포함될 수 없음(Kruskal의 배제 원리)
- **시간복잡도 정리**
  - Prim(힙, 인접 리스트): `O(E log V)`
  - Kruskal(정렬 + Union-Find): `O(E log E)` ≈ `O(E log V)`
  - Dijkstra(힙, 인접 리스트): `O(E log V)`
- **구현 요령**
  - Prim: 힙에 같은 정점이 여러 번 들어갈 수 있어 **pop 시 visited 검사** 필수
  - Kruskal: **무방향 간선은 (u,v) 한 번만** 넣기, Union-Find 필수
  - Dijkstra: **음수 간선 금지**, 도달 불가 노드는 `INF` 유지

# 💡 예시 코드
```python
# Prim (인접 리스트 + 힙)
import heapq
def prim_mst(graph, start=0):
    n = len(graph)
    visited = [False]*n
    pq = [(0, start, -1)]  # (w, v, parent)
    total, edges = 0, []
    while pq:
        w, v, p = heapq.heappop(pq)
        if visited[v]: 
            continue
        visited[v] = True
        total += w
        if p != -1:
            edges.append((p, v, w))
        for nv, nw in graph[v]:
            if not visited[nv]:
                heapq.heappush(pq, (nw, nv, v))
    return edges, total
```

```python
# Kruskal (Union-Find: 경로 압축 + 랭크)
def find(p, x):
    if p[x] != x: p[x] = find(p, p[x])
    return p[x]

def union(p, r, a, b):
    ra, rb = find(p,a), find(p,b)
    if ra == rb: return False
    if r[ra] < r[rb]: p[ra] = rb
    elif r[ra] > r[rb]: p[rb] = ra
    else: p[rb] = ra; r[ra] += 1
    return True

def kruskal_mst(n, edges):
    # edges: [(w,u,v), ...]
    edges.sort()
    p = list(range(n)); r = [0]*n
    total, mst = 0, []
    for w,u,v in edges:
        if union(p,r,u,v):
            mst.append((u,v,w)); total += w
    return mst, total
```

```python
# Dijkstra (인접 리스트 + 힙), 음수 간선 금지
import heapq
INF = 10**18
def dijkstra(graph, s):
    n = len(graph)
    dist = [INF]*n; dist[s] = 0
    parent = [-1]*n
    pq = [(0, s)]
    while pq:
        d,u = heapq.heappop(pq)
        if d != dist[u]: 
            continue
        for v,w in graph[u]:
            nd = d + w
            if nd < dist[v]:
                dist[v] = nd; parent[v] = u
                heapq.heappush(pq, (nd, v))
    return dist, parent

def path(parent, t):
    rev = []
    while t != -1: rev.append(t); t = parent[t]
    return rev[::-1]
```

# 🛠️ 이슈 & 해결
| 🐞 문제 상황 | 🔍 원인 | 💡 해결 방법 |
|--------------|--------|--------------|
| Prim에서 동일 정점이 힙에 중복 삽입되어 가중치 중복 합산 | pop 시 방문 체크 누락 | `if visited[v]: continue`로 방지 |
| Kruskal에서 사이클 미검출 | Union-Find 미사용/오류 | 경로 압축 + 랭크 기반 합치기 적용 |
| 무방향 간선 중복 처리로 가중치 2배 | (u,v),(v,u) 모두 삽입 | 입력 단계에서 한 번만 삽입 |
| Dijkstra 결과가 틀림 | 음수 간선 포함/완화 조건 오류 | 음수 간선이면 Bellman-Ford로 전환, `if nd < dist[v]` 엄격 적용 |
| 인접 행렬 버전에서 TLE | 희소 그래프에서 V^2 스캔 | 인접 리스트 + 힙으로 전환 (`O(E log V)`) |

# 🎯 내일 할 일
- 📚 Prim/Kruskal/Dijkstra를 각각 **인접 행렬 vs 인접 리스트**로 구현해 성능 비교
- 💻 MST/최단경로 실전 문제 풀이 및 유닛 테스트 추가 (임의 그래프 생성기 활용)
- 🔍 Dijkstra 경로 복원 및 도달 불가 케이스(분리 그래프) 처리 점검
