# 2025-09-15 TIL

# ✅ 오늘 한 일

* 그래프 기본 개념 및 표현 방식 학습
* DFS, BFS 탐색 원리와 구현 방식 정리
* Union-Find(Disjoint Set, 서로소 집합) 개념 및 연산 학습

# 📚 배운 점

* 그래프는 정점(Vertex)과 간선(Edge)으로 구성되며, 유형에 따라 무향/유향/가중치/사이클 없는 그래프로 나뉜다.
* 그래프 표현 방식: 인접 행렬, 인접 리스트, 간선 배열.
* DFS는 깊이 우선 탐색, BFS는 너비 우선 탐색으로 방문 순서가 다르다.
* Union-Find는 집합을 트리/배열 구조로 표현하며, `Make-Set`, `Find-Set`, `Union` 연산을 통해 집합을 관리한다.
* 효율성을 위해 **랭크 기반 합치기(Union by Rank)**와 **경로 압축(Path Compression)** 기법을 적용한다.

# 📌 핵심 개념

* **그래프 최대 간선 수**: |E| = |V|(|V|-1)/2
* **인접 행렬 vs 인접 리스트**

  * 행렬: 구현 간단, 공간 낭비 가능
  * 리스트: 메모리 효율적, 탐색 시 연결된 정점만 확인
* **DFS**: 스택/재귀 기반 깊이 탐색
* **BFS**: 큐 기반 너비 탐색
* **Union-Find 최적화**

  * Path compression: 탐색 시 부모를 루트로 갱신
  * Union by rank: 트리 높이를 최소화

# 💡 예시 코드

```python
# DFS (재귀)
def dfs(v, visited, graph):
    visited[v] = True
    print(v, end=" ")
    for nxt in graph[v]:
        if not visited[nxt]:
            dfs(nxt, visited, graph)

# BFS (큐)
from collections import deque
def bfs(start, graph):
    visited = [False] * len(graph)
    q = deque([start])
    visited[start] = True
    while q:
        v = q.popleft()
        print(v, end=" ")
        for nxt in graph[v]:
            if not visited[nxt]:
                visited[nxt] = True
                q.append(nxt)

# Union-Find
def find(x):
    if parent[x] != x:
        parent[x] = find(parent[x])  # Path compression
    return parent[x]

def union(x, y):
    rx, ry = find(x), find(y)
    if rank[rx] < rank[ry]:
        parent[rx] = ry
    elif rank[rx] > rank[ry]:
        parent[ry] = rx
    else:
        parent[ry] = rx
        rank[rx] += 1
```

# 🛠️ 이슈 & 해결

| 🐞 문제 상황             | 🔍 원인                      | 💡 해결 방법                            |
| -------------------- | -------------------------- | ----------------------------------- |
| 인접 행렬 사용 시 메모리 낭비 발생 | 정점 수에 비해 간선 수가 적음 (희소 그래프) | 인접 리스트 사용으로 전환                      |
| Union-Find 연산이 느림    | 편향 트리 구조 발생                | Path Compression + Union by Rank 적용 |

# 🎯 내일 할 일

* 📚 그래프 탐색 응용 문제(미로 탐색, 연결 요소 개수 등) 풀기
* 💻 DFS/BFS/Union-Find를 직접 구현 및 실습
