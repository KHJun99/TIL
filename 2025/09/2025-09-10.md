# 2025-09-10 TIL

# ✅ 오늘 한 일
- **분할 정복 수업 내용 정리**

# 📚 배운 점
- **분할 정복 기법**
- **병합 정렬**
- **퀵 정렬**
- **이진 검색**

# 📌 핵심 개념
## 분할 정복 기법
- 분할 정복 :
  - 문제를 작은 하위 문제로 나누고(분할) 각각을 해결(정복)한 뒤, 그 결과를 결합(통합)하여 원래 문제를 해결하는 알고리즘 기법
- 분할(Divide) : 해결할 문제를 여러 개의 작은 부분으로 나눔
- 정복(Comquer) : 나눈 작은 문제를 각각 해결
- 통합(Combine) : (필요하다면) 해결된 해답을 모음
## 병합 정렬
- Merge Sort
- 여러 개의 정렬된 자료의 집합을 병합하여 한 개의 정렬된 집합으로 만드는 방식
- 시간 복잡도 : O(n log n)
### 병합 정렬 과정
- 자료를 최소 단위의 문제까지 나눈 후에 차례대로 정렬하여 최종 결과 도출
- top-down 방식
- 분할 단계 : 전체 자료 집합에 대해 최소 크기의 부분집합이 될 때까지 분할 작업 진행
- 병합 단계 : 2개의 부분집합을 정렬하면서 하나의 집합으로 병합

## 퀵 정렬
- 기준값을 중심으로 주어진 배열을 두 개로 분할하고, 각각을 정렬하여 전체 배열을 정렬
- Partitioning 과정 반복 --> 빠른 속도로 정렬되는 알고리즘
- 시간 복잡도 : 
  - 평균 : O(N log N)
  - 최악 : O(N^2)
- 데이터가 많을수록 유리
### 병합 정렬과 퀵 정렬의 차이
- 병합 정렬
  - 단순히 배열을 반으로 나눔
  - 정렬된 부분을 다시 병합하는 과정 필요
- 퀵 정렬
  - 기준 아이템(pivot)을 중심으로 기준보다 작은 것을 왼편, 큰 것을 오른편에 위치
  - 별도의 병합 과정 불필요
### Partitioning
- 파트셔닝이 끝나고 Pivot의 위치를 확정(Fix)
- 즉, 정렬이 다 되었을 때에도 Pivot의 위치는 지금 위치 그대로 배정
- 한 번의 파티셔닝 이후, 왼쪽과 오른쪽 부분 배열에 대해 재귀적으로 파티셔닝을 반복하여 정렬 진행
### Partitioning 순서
1. 작업 영역을 정한다.
2. 작업 영역 중 가장 왼쪽에 있는 수를 Pivot
3. Pivot을 기준으로
   - 왼쪽에는 Pivot보다 작은 수를 배치 (정렬 x)
   - 오른쪽에는 Pivot보다 큰 수를 배치 (정렬 x)

## 이진 검색
- Binary Search
- 자료의 가운데에 있는 항목의 키 값과 비교하여 다음 검색의 위치를 결정하고 검색을 계속 진행
- 자료가 정렬된 상태에서만 사용 가능
### 이진 검색 과정
1. 자료의 중앙에 있는 원소를 선택
2. 중앙 원소의 값과 찾고자 하는 목표 값 비교
3. 목표값 < 중앙 원소 : 자료의 왼쪽 반에 대해서 새로 검색 수행
4. 목표값 > 중앙 원소 : 자료의 오른쪽 반에 대해서 새로 검색 수행
5. 찾고자 하는 값을 찾을 때까지 1~3번 과정 반복
# 💡 예시 코드
## 병합 정렬 코드
```python
# 1. 분할
# 2. 정복 & 병합(정렬)

# 정복 & 병합(정렬) 함수
def merge(left, right):
		# 두 리스트를 병합한 결과 리스트
		result = [0] * (len(left) + len(right))
		l = r = 0    # 인덱스
		
		# 두 리스트에서 비교할 대상이 남아있을 때 까지 반복
		while l < len(left) and r < len(right):
				if left[l] < right[r]:
						result[l + r] = left[l]    # result 에 더 작은 걸 삽입
						l += 1
				else:
						result[l + r] = right[r]
						r += 1
		# 왼쪽 리스트에 남은 데이터들을 모두 result에 추가
		while l < len(left):
				result[l + r] = left[l]
				l += 1
		
		# 오른쪽 리스트에 남은 데이터들을 모두 result에 추가
		while r < len(right):
				result[l + r] = right[r]
				r += 1
		
		return result
		

# 분할 함수
def merge_sort(li):
		if len(li) == 1:
				return li
				
		# 절반 씩 분할
		mid = len(li) // 2
		left = li[:mid]
		right = li[mid:]
		
		left_list = merge_sort(left)
		right_list = merge_sort(right)
		
		merge_list = merge(left_list, right_list)
		return merge_list
		
		
arr = [69, 10, 30, 2, 16, 8, 31, 22]
sorted_arr = merge_sort(arr)
print(sorted_arr)
```
## 퀵 정렬 코드
```python
# 피벗: 제일 왼쪽 요소
# 이미 정렬된 배열이나 역순으로 정렬된 배열에서 최악의 성능을 보일 수 있음
def hoare_partition1(left, right):
    pivot = arr[left]  # 피벗을 제일 왼쪽 요소로 설정
    i = left + 1
    j = right

    while i <= j:
        while i <= j and arr[i] <= pivot:
            i += 1

        while i <= j and arr[j] >= pivot:
            j -= 1

        if i < j:
            arr[i], arr[j] = arr[j], arr[i]

    arr[left], arr[j] = arr[j], arr[left]
    return j
    
def quick_sort(left, right):
    if left < right:
        pivot = hoare_partition1(left, right)
        # pivot = hoare_partition2(left, right)
        # pivot = hoare_partition3(left, right)
        quick_sort(left, pivot - 1)
        quick_sort(pivot + 1, right)


quick_sort(0, len(arr) - 1)
print(arr)
```
## 이진 검색 코드
```python
def binary_search_while(target):
		left = 0                 # 검색 시작점
		right - len(arr) - 1     # 검색 끝점
		cnt = 0                  # 검색 횟수
		
		while left <= right:     # 교차되면 못찾은 것
				mid = (left + right) // 2
				cnt += 1
				
				if arr[mid] == targer:
						return mid, cnt       # mid 위치에 존재한다고 return
						
				# target 보다 정답이 왼쪽에 있는 경우
				if target < arr[mid]:
						right = mid - 1    # mid 사용 안하는 경우 이렇게 작성
				# target 보다 정답이 오른쪽에 있는 경우
				else:
						left = mid + 1
		# 못찾은 경우
		return -1, cnt
		
# 이진 검색 재귀 호출
def binary_search_recur(left, right, target):
		# left, right 를 작업 영역으로 검색
		# left <= right 만족하면 반복
		if left > right:
				return -1
		
		mid = (left + right) // 2
		# 검색하면 종료
		if target == arr[mid]:
				return mid
				
		# 한 번 할 때마다 left 와 right를 mid 기준으로 이동시켜 주면서 진행
		# 왼쪽을 봐야한다.
		if target < arr[mid]:
				return binary_search_recur(left, mid - 1, target)
		# 오른쪽을 봐야한다.
		else:
				return binary_search_recur(mid + 1, right, target)
		
arr = [4, 2, 9, 7, 11, 23, 19]

# 이진 검색은 항상 정렬된 데이터에 적용
arr.sort()

print(f'9 =  {binary_search_while(9)}번째에 위치')    
```


# 🛠️ 이슈 & 해결
| 🐞 문제 상황 | 🔍 원인 | 💡 해결 방법 |
|--------------|--------|--------------|
|  |  |  |

# 🎯 내일 할 일
- 📚 
- 💻 
