# 2025-09-12 TIL

# ✅ 오늘 한 일
- SWEA/BOJ 문제 풀이 정리 (1486, 1952, 2819, 1861)
- 재귀/백트래킹, BFS/DFS, DP, Union-Find 활용 복습
- 가지치기(pruning)와 상태 공간 축소 아이디어 실습

# 📚 배운 점
- **부분집합/백트래킹**으로 최적해를 찾을 때는 조기 종료(가지치기)로 탐색량을 줄인다.
- **DP**는 “부분 문제의 최소/최대”를 누적하는 방식으로 설계하고, 기준(전이) 정의가 핵심이다.
- **BFS/DFS**에서 상태(좌표·누적 문자열 등)를 큐/스택에 함께 담아 전파하면 중복 계산을 줄일 수 있다.
- 격자/수열 문제는 “이동 규칙 ↔ 상태 정의 ↔ 종료 조건”을 먼저 명확히 잡으면 구현이 쉬워진다.

# 📌 핵심 개념
- **1486 장훈이의 높은 선반**: 부분집합 탐색 + `height 합 >= B` 시 즉시 갱신/리턴으로 pruning → 최소 초과분 `min_answer - B` 출력
- **1952 수영장**:
  - 재귀: 월 단위로 (1일/1달/3달/1년) 4가지 선택 탐색, 최소 비용 갱신
  - DP: `dp[m] = min(dp[m-1]+일권/월권, dp[m-3]+3달권)` 후 `min(dp[12], 1년)`
- **2819 숫자 이어 붙이기**: 4×4 격자에서 상하좌우로 6번 이동(총 7자리), DFS/BFS로 7자리 도달 시 `set`에 삽입해 중복 제거
- **1861 정사각형 방**:
  - 구현형: 각 칸에서 값+1이 인접에 있는지 여부를 `visited[val]=1`로 마킹 → 연속된 1의 최장 길이로 정답 도출
  - DFS형: 상하좌우로 값이 정확히 +1인 경우만 연쇄 이동, 최장 길이·시작값 갱신

# 💡 예시 코드
```python
# 1486. 부분집합 + 가지치기
def recur(idx, total):
    global ans
    if total >= B:
        ans = min(ans, total); return
    if idx == N: 
        return
    recur(idx+1, total + H[idx])   # 선택
    recur(idx+1, total)            # 비선택
```

```python
# 1952. DP 전이
dp = [0]*13
dp[1] = min(days[1]*d, m)
dp[2] = dp[1] + min(days[2]*d, m)
for mo in range(3, 13):
    dp[mo] = min(dp[mo-1] + min(days[mo]*d, m),
                 dp[mo-3] + m3)
ans = min(dp[12], y)
```

```python
# 2819. DFS로 7자리 생성
dirs = [(-1,0),(1,0),(0,-1),(0,1)]
def dfs(y,x,s):
    if len(s) == 7:
        seen.add(s); return
    for dy,dx in dirs:
        ny,nx = y+dy, x+dx
        if 0 <= ny < 4 and 0 <= nx < 4:
            dfs(ny,nx,s+board[ny][nx])
```

```python
# 1861. 인접에 +1 존재 여부만 체크
mark = [0]*(N*N+1)
for y in range(N):
    for x in range(N):
        v = A[y][x]
        for dy,dx in dirs:
            ny,nx = y+dy, x+dx
            if 0 <= ny < N and 0 <= nx < N and A[ny][nx] == v+1:
                mark[v] = 1; break
# 연속된 1의 최장 구간 길이와 시작값 구하기
```

# 🛠️ 이슈 & 해결
| 🐞 문제 상황 | 🔍 원인 | 💡 해결 방법 |
|--------------|--------|--------------|
| 1486에서 시간 초과 | 모든 부분집합 탐색 | `total >= B` 시 즉시 반환(pruning) |
| 1952 DP 인덱스 오류 | `dp[mo-3]` 경계 처리 누락 | 1~2월 기저값 명시, 3월부터 전이 |
| 2819에서 중복 카운트 | 동일 7자리 재방문 | `set`으로 유니크 관리 |
| 1861에서 오답 | DFS 전수 탐색으로 TLE | “+1 존재 여부” 마킹법으로 선형화 |

# 🎯 내일 할 일
- 📚 2819/1861를 비트마스크·메모이제이션으로 최적화 시도
- 💻 1952를 탑다운 DP(메모이제이션) 버전으로 재작성 및 케이스 테스트
- 🔍 1486에 대해 정렬+가지치기(남은 최대치로 상한 추정) 적용 실험
