# 2025-09-30 TIL

# ✅ 오늘 한 일
- HTTP의 특성과 무상태성 보완을 위한 **쿠키·세션 메커니즘** 정리
- Django **Authentication System**(로그인/세션/컨텍스트 프로세서) 흐름 학습
- **Custom User Model(대체형)**로 프로젝트 시작 시 설정해야 하는 이유 및 절차 복기
- 로그인 폼(AuthenticationForm) 기반 **로그인 구현 실습**
- 라디오 버튼 표시 및 POST 키 불일치로 인해 값이 안 넘어가던 **폼 이슈 디버깅**

# 📚 배운 점
- **HTTP = 비연결(Connectionsless) + 무상태(Stateless)** → 상태 유지를 위해 쿠키·세션 필요
- **쿠키**: 클라이언트 저장(Key-Value), `Set-Cookie`/`Cookie` 헤더로 왕복, 만료/도메인/경로 등 속성
- **세션**: 서버 저장(메모리/DB), 클라이언트는 **세션ID만 쿠키에 보관**하여 인증 지속
- **Django 세션**: 기본이 DB 백엔드(`django_session`), 요청의 쿠키에 담긴 세션ID로 매핑
- **Django Auth**: 사용자 모델, 세션관리, 기본 인증 폼 제공 → 로그인은 “인증 성공 → 세션 발급/연결”의 과정
- **Custom User Model**은 프로젝트 초기에 반드시 진행(마이그레이션 전) → `AUTH_USER_MODEL = "accounts.User"`
- **context processors** 덕분에 템플릿에서 `user` 등 인증 관련 컨텍스트를 바로 사용 가능

# 📌 핵심 개념
- 쿠키 vs 세션
  - 저장 위치: (쿠키) 클라 / (세션) 서버
  - 보안성: 세션이 상대적으로 안전(민감정보는 서버 보관, 클라에는 ID만)
  - 수명: 세션 쿠키/영속 쿠키(Expires/Max-Age), 세션은 서버 정책에 따름
- 쿠키 보안 속성: `HttpOnly`, `Secure`, `SameSite`, `Domain`, `Path`, `Expires/Max-Age`

# 💡 예시 코드

## 1) Django: 간단 쿠키 설정/조회
```python
# views.py
from django.http import HttpResponse

def set_cart_cookie(request):
    resp = HttpResponse("cart set")
    # 1시간 유지(Max-Age=3600), JS에서 접근 불가(HttpOnly), HTTPS에서만 전송(Secure)
    resp.set_cookie("cart", "A1001,B2002", max_age=3600, httponly=True, secure=True, samesite="Lax")
    return resp

def get_cart_cookie(request):
    cart = request.COOKIES.get("cart", "")
    return HttpResponse(f"cart={cart}")
```

## 2) Django: 로그인(AuthenticationForm 사용)
```python
# urls.py
from django.urls import path
from . import views
urlpatterns = [
    path("login/", views.login_view, name="login"),
    path("logout/", views.logout_view, name="logout"),
]
```
```python
# views.py
from django.contrib.auth.forms import AuthenticationForm
from django.contrib.auth import login, logout
from django.shortcuts import render, redirect

def login_view(request):
    if request.method == "POST":
        form = AuthenticationForm(request, data=request.POST)
        if form.is_valid():
            user = form.get_user()
            login(request, user)  # 세션 생성 및 연결
            return redirect("home")
    else:
        form = AuthenticationForm(request)
    return render(request, "accounts/login.html", {"form": form})

def logout_view(request):
    logout(request)  # 세션 해제
    return redirect("home")
```
```html
<!-- templates/accounts/login.html -->
<h1>로그인</h1>
<form method="post">
  {% csrf_token %}
  {{ form.as_p }}
  <button>로그인</button>
</form>
```

## 3) Custom User Model(대체)
```python
# accounts/models.py
from django.contrib.auth.models import AbstractUser
from django.db import models

class User(AbstractUser):
    # 확장 예시
    # birth_date = models.DateField(null=True, blank=True)
    pass
```
```python
# settings.py
AUTH_USER_MODEL = "accounts.User"
```
```python
# accounts/admin.py
from django.contrib import admin
from .models import User
admin.site.register(User)
```

# 🛠️ 이슈 & 해결
| 🐞 문제 상황 | 🔍 원인 | 💡 해결 방법 |
|--------------|--------|--------------|
| 템플릿에서 **라디오 버튼(주차 가능 여부)**가 표시되지 않음 | `<p for="...">`처럼 `for`가 잘못된 곳에 있음 + `name` 오타(`is_parking_avaliable`) | `<label for="...">`만 사용하고, `<input id="...">`와 짝 맞추기. `name="is_parking_available"`로 **POST 키를 뷰와 일치** |
| 뷰에서 `request.POST.get('is_parking_available')`가 항상 `None` | 템플릿의 `name` 속성 오타로 키 불일치 | 템플릿과 뷰의 키를 동일하게(`is_parking_available`) 통일 |
| Boolean 라디오 값 파싱 문제 | 라디오 value가 문자열 `"True"/"False"` | `ipa_raw in ['True','true','1','on']`처럼 안전 변환 or `value="on"`/체크 여부로 처리 |

### 수정된 폼 스니펫
```html
<p>주차 가능 여부</p>
<label for="is_parking_available_true">
  가능
  <input type="radio" id="is_parking_available_true" name="is_parking_available" value="True">
</label>
<label for="is_parking_available_false">
  불가능
  <input type="radio" id="is_parking_available_false" name="is_parking_available" value="False">
</label>
```

### 수정된 create 뷰 스니펫
```python
ipa_raw = request.POST.get("is_parking_available")
is_parking_available = ipa_raw in ["True", "true", "1", "on"]
```

# 🎯 내일 할 일
- 📚 Django Auth 심화: **로그인 상태에 따른 네비게이션/접근 제어**, `@login_required`, `next` 파라미터 처리
- 💻 Custom User에 **추가 필드**(예: 닉네임/생년월일) 적용 후 폼/마이그레이션/어드민까지 연결
- 🔐 쿠키 보안 속성 실험: `HttpOnly/Secure/SameSite` 조합별 브라우저 동작 관찰
- 🧪 세션 만료/로그아웃/브라우저 종료 시 동작 케이스 테스트

# 참고
- Django 공식문서: https://docs.djangoproject.com/en/5.2/topics/auth/customizing/#substituting-a-custom-user-model
