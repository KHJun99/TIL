# 2025-11-19 TIL

# ✅ 오늘 한 일
- JavaScript 객체(Object) 개념 및 속성 조작 학습
- 메서드와 this 키워드 학습
- 추가 객체 문법 학습 (단축 속성, 구조 분해 할당, 전개 구문 등)
- JSON과 JavaScript 객체 간 변환 학습
- 배열(Array) 메서드 학습 (push, pop, shift, unshift)
- Array Helper Methods 학습 (forEach, map)
- 콜백 함수 개념 이해 및 활용
- 클래스 기본 문법 학습

# 📚 배운 점
- 객체는 key-value 쌍으로 구성되며, key는 문자형만, value는 모든 자료형 허용
- this는 함수가 호출되는 방식에 따라 동적으로 결정되며, 화살표 함수는 자신만의 this를 가지지 않음
- 구조 분해 할당을 사용하면 객체의 속성을 변수에 쉽게 할당할 수 있음
- Optional chaining(?.)을 사용하면 중첩 객체 접근 시 에러 없이 안전하게 접근 가능
- JSON은 문자열 형태의 데이터 표기법으로, API 통신에서 널리 사용됨
- forEach는 undefined를 반환하고, map은 새로운 배열을 반환하는 차이가 있음
- 콜백 함수는 다른 함수의 인자로 전달되어 나중에 호출되는 함수
- shift와 unshift는 배열의 모든 요소를 이동시켜야 하므로 성능이 저하될 수 있어 가급적 사용 지양
- 전개 구문을 사용하면 원본 배열을 수정하지 않고 새로운 배열 생성 가능

# 📌 핵심 개념
- **객체 (Object)**: key-value 쌍으로 구성된 데이터 집합을 저장하는 자료형
- **this 키워드**: 함수나 메서드를 호출한 객체를 가리키는 키워드로, 호출 방식에 따라 동적으로 결정됨
- **구조 분해 할당**: 배열이나 객체를 분해하여 속성을 변수에 쉽게 할당하는 문법
- **Optional chaining (?.)**: 속성이 없는 중첩 객체 접근 시 에러 없이 undefined를 반환
- **JSON (JavaScript Object Notation)**: key-value 형태의 문자열 데이터 표기법
- **콜백 함수**: 다른 함수의 인자로 전달되어 특정 시점에 호출되는 함수
- **forEach()**: 배열의 각 요소에 대해 콜백 함수를 실행하며 undefined 반환, break 사용 불가
- **map()**: 배열의 각 요소에 대해 콜백 함수를 실행하고 그 결과를 모아 새로운 배열 반환
- **전개 구문 (...)**: 배열이나 객체를 개별 요소로 펼치며, 원본을 변경하지 않고 복사본 생성

# 💡 예시 코드

```javascript
// 객체 생성 및 속성 조작
const user = {
  name: 'Alice',
  'key with space': true,
  greeting: function () {
    return 'hello'
  }
};

console.log(user.name); // Alice (점 표기법)
console.log(user['key with space']); // true (대괄호 표기법)

// 속성 추가, 수정, 삭제
user.address = 'korea';
user.name = 'Bella';
delete user.address;

// in 연산자
console.log('greeting' in user); // true

// this 키워드
const person = {
  name: 'Alice',
  greeting: function () {
    return `Hello my name is ${this.name}`;
  },
};
console.log(person.greeting()); // Hello my name is Alice

// 화살표 함수와 this (중첩 함수 문제 해결)
const myObj = {
  numbers: [1, 2, 3],
  myFunc: function () {
    this.numbers.forEach((number) => {
      console.log(this); // myObj (화살표 함수는 외부 this 사용)
    });
  }
};

// 단축 속성
const name = 'Alice';
const age = 30;
const user2 = { name, age }; // { name: 'Alice', age: 30 }

// 구조 분해 할당
const userInfo = {
  firstName: 'Alice',
  userId: 'alice123',
  email: 'alice123@gmail.com'
};
const { firstName, userId, email } = userInfo;

// 함수 매개변수에서 구조 분해 할당
function printInfo({ name, age, city }) {
  console.log(`이름: ${name}, 나이: ${age}, 도시: ${city}`);
}
printInfo({ name: 'Bob', age: 35, city: 'London' });

// 전개 구문
const obj = { b: 2, c: 3, d: 4 };
const newObj = { a: 1, ...obj, e: 5 };
console.log(newObj); // {a: 1, b: 2, c: 3, d: 4, e: 5}

// Optional chaining
const user3 = { name: 'Alice' };
console.log(user3.address?.street); // undefined (에러 없이 안전하게 접근)

// JSON 변환
const jsObject = { coffee: 'Americano', iceCream: 'Cookie and cream' };
const objToJson = JSON.stringify(jsObject); // Object → JSON
const jsonToObj = JSON.parse(objToJson); // JSON → Object

// 배열 메서드
const names = ['Alice', 'Bella', 'Cathy'];
names.push('Dan'); // 끝에 추가
names.pop(); // 끝에서 제거
// names.unshift('Eric'); // 앞에 추가 (성능 저하 가능성, 가급적 지양)
// names.shift(); // 앞에서 제거 (성능 저하 가능성, 가급적 지양)

// forEach
names.forEach((name, index) => {
  console.log(`${name} / ${index}`);
});
// Alice / 0
// Bella / 1
// Cathy / 2

// map (새로운 배열 반환)
const persons = [
  { name: 'Alice', age: 20 },
  { name: 'Bella', age: 21 }
];

const personNames = persons.map((person) => person.name);
console.log(personNames); // ['Alice', 'Bella']

const nameLengths = names.map(name => name.length);
console.log(nameLengths); // [5, 5, 5]

// 콜백 함수
const numbers = [1, 2, 3];
const callBackFunction = function (num) {
  console.log(num);
};
numbers.forEach(callBackFunction);

// 배열과 전개 구문
let parts = ['어깨', '무릎'];
let lyrics = ['머리', ...parts, '발'];
console.log(lyrics); // ['머리', '어깨', '무릎', '발']

// 클래스
class Member {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
  sayHi() {
    console.log(`Hi, I am ${this.name}`);
  }
}

const member = new Member('Alice', 20);
console.log(member.name); // Alice
member.sayHi(); // Hi I am Alice
```

# 🛠️ 이슈 & 해결
| 🐞 문제 상황 | 🔍 원인 | 💡 해결 방법 |
|--------------|--------|--------------|
| forEach 안에서 this가 window를 가리킴 (중첩 함수 문제) | 콜백 함수가 일반 함수로 호출되어 this가 전역 객체를 가리킴 | 화살표 함수를 사용하면 외부 함수의 this를 그대로 사용할 수 있음 |
| Optional chaining을 남용하여 실제 오류를 발견하지 못함 | 필수값에도 Optional chaining을 사용하여 문제가 숨겨짐 | 존재하지 않아도 괜찮은 대상에만 선택적으로 사용. 필수값에는 일반 접근 사용 |
| JSON.stringify로 변환했는데 다시 사용할 수 없음 | JSON은 문자열이므로 JavaScript에서 직접 사용 불가 | JSON.parse()를 사용하여 다시 객체로 변환 후 사용 |
| map과 forEach의 차이를 몰라 잘못 사용함 | forEach는 undefined 반환, map은 새 배열 반환 | 반환값이 필요하면 map, 단순 순회만 필요하면 forEach 사용 |
| shift/unshift 사용 후 성능 저하 발생 | 배열의 모든 요소를 이동시켜야 하므로 성능 저하 | 가급적 push/pop 사용. 불가피한 경우에만 shift/unshift 사용 |