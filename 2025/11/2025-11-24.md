# 2025-11-24 TIL

# ✅ 오늘 한 일
- JavaScript의 동기(Synchronous)와 비동기(Asynchronous) 처리 방식 학습
- JavaScript Runtime 환경과 비동기 처리 메커니즘 이해
- Call Stack, Web API, Task Queue, Event Loop의 역할 학습
- Ajax 개념과 목적 학습
- XMLHttpRequest(XHR) 객체 개념 이해
- 기존 방식과 Ajax의 차이점 비교

# 📚 배운 점
- JavaScript는 Single Thread 언어지만 브라우저 환경(Runtime)의 도움으로 비동기 처리가 가능함
- 동기 방식은 순차적으로 실행되어 예측 가능하지만, 시간이 오래 걸리는 작업 시 프로그램이 멈춤
- 비동기 방식은 병렬적으로 작업을 수행하여 효율적이지만, 코드의 복잡성이 증가함
- Call Stack은 함수 호출이 쌓이는 공간이고, Web API는 비동기 작업을 처리하는 브라우저 환경
- Task Queue는 Web API에서 완료된 작업이 대기하는 곳이고, Event Loop는 Call Stack이 비었을 때 Task Queue의 작업을 옮김
- Ajax는 페이지 전체를 새로고침하지 않고 서버와 비동기적으로 데이터를 주고받는 기술
- Ajax를 사용하면 부분 업데이트가 가능하여 사용자 경험(UX)이 향상됨
- 이벤트 핸들러도 비동기 프로그래밍의 한 형태임
- Ajax의 'X'는 원래 XML을 의미했지만, 현재는 JSON 형식을 주로 사용함

# 📌 핵심 개념
- **동기(Synchronous)**: 작업이 순차적으로 실행되며, 하나의 작업이 완료되어야 다음 작업이 시작되는 방식
- **비동기(Asynchronous)**: 작업의 완료를 기다리지 않고 다음 작업을 즉시 실행하는 방식
- **Single Thread**: JavaScript는 한 번에 하나의 작업만 처리할 수 있는 언어
- **JavaScript Runtime**: JavaScript가 비동기 처리를 할 수 있도록 도와주는 환경 (브라우저, Node.js)
- **Call Stack**: 함수 호출이 순서대로 쌓이는 작업 공간
- **Web API**: 브라우저에서 제공하는 비동기 작업 처리 환경
- **Task Queue**: Web API에서 완료된 작업이 순서대로 대기하는 대기열
- **Event Loop**: Call Stack이 비어있는지 확인하고, 비는 순간 Task Queue의 작업을 Call Stack으로 보내는 역할
- **Ajax (Asynchronous JavaScript and XML)**: 페이지 새로고침 없이 서버와 비동기적으로 데이터를 주고받는 기술
- **XMLHttpRequest(XHR)**: 웹 브라우저와 서버 간의 비동기 통신을 가능하게 하는 JavaScript 객체

# 💡 예시 코드

```javascript
// 1. 동기(Synchronous) 코드 예시
console.log('작업 1 시작');

const syncTask = function() {
  for (let i = 0; i < 10000000000; i++) {
    // 반복 실행 동안 대기
  }
  return '작업 완료';
};

const result = syncTask();
console.log(result);
console.log('작업 2 시작');

// 출력 결과:
// 작업 1 시작
// (반복 실행 동안 대기)
// 작업 완료
// 작업 2 시작

// 2. 비동기(Asynchronous) 코드 예시
console.log('작업 1 시작');

const asyncTask = function(callback) {
  setTimeout(() => {
    callback('작업 완료');
  }, 3000);
};

asyncTask((result) => {
  console.log(result);
});

console.log('작업 2 시작');

// 출력 결과:
// 작업 1 시작
// 작업 2 시작
// (3초 후)
// 작업 완료

// 3. 이벤트 루프 동작 과정 예시
console.log('Hi');

setTimeout(function myFunc() {
  console.log('Work');
}, 3000);

console.log('Bye');

// 출력 결과:
// Hi
// Bye
// (3초 후)
// Work

// 동작 과정:
// 1. console.log('Hi')가 Call Stack에 쌓임 → 즉시 실행 → 'Hi' 출력
// 2. setTimeout이 Call Stack에 쌓임 → Web API로 전달
// 3. console.log('Bye')가 Call Stack에 쌓임 → 즉시 실행 → 'Bye' 출력
// 4. Web API에서 3초 후 myFunc를 Task Queue로 전달
// 5. Event Loop가 Call Stack이 비어있음을 확인
// 6. Task Queue에서 myFunc를 Call Stack으로 이동
// 7. console.log('Work')가 실행 → 'Work' 출력

// 4. 여러 비동기 작업 예시
console.log('시작');

setTimeout(() => {
  console.log('첫 번째 타이머 (1초)');
}, 1000);

setTimeout(() => {
  console.log('두 번째 타이머 (0초)');
}, 0);

console.log('끝');

// 출력 결과:
// 시작
// 끝
// 두 번째 타이머 (0초)
// 첫 번째 타이머 (1초)
// 
// setTimeout은 0초라도 Web API를 거쳐 Task Queue에 들어가므로
// 동기 코드가 모두 실행된 후에 실행됨
```

```javascript
// Ajax와 기존 방식의 차이

// 기존 방식 (페이지 전체 새로고침)
// 1. 사용자가 form 제출
// 2. 서버가 전체 페이지를 새로 생성
// 3. 브라우저가 전체 페이지를 다시 로드
// → 모든 요청마다 새로고침 발생, 대역폭 낭비

// Ajax 방식 (부분 업데이트)
// 1. XHR 객체 생성 및 요청
// 2. 서버가 필요한 데이터만 JSON으로 응답
// 3. JavaScript로 페이지 일부만 업데이트
// → 새로고침 없음, 필요한 데이터만 전송, 사용자 경험 향상
```

# 🛠️ 이슈 & 해결
| 🐞 문제 상황 | 🔍 원인 | 💡 해결 방법 |
|--------------|--------|--------------|
| setTimeout을 0초로 설정했는데도 동기 코드보다 늦게 실행됨 | setTimeout은 시간과 관계없이 Web API를 거쳐 Task Queue에 들어가기 때문 | Event Loop는 Call Stack이 완전히 비어야 Task Queue의 작업을 가져옴. 0초라도 비동기 작업이므로 동기 코드가 모두 실행된 후 실행됨 |
| 비동기 작업의 결과를 바로 사용하려 했으나 undefined가 나옴 | 비동기 작업은 즉시 완료되지 않으므로 결과가 아직 없는 상태 | 콜백 함수나 Promise를 사용하여 비동기 작업이 완료된 후 결과를 처리해야 함 |
| JavaScript가 Single Thread인데 어떻게 여러 작업을 동시에 처리하는지 이해 안 됨 | JavaScript 자체는 Single Thread지만 브라우저 환경이 비동기 처리를 지원함 | Web API가 비동기 작업을 별도로 처리하고, Event Loop가 완료된 작업을 Call Stack으로 전달하여 비동기 처리가 가능함 |
| Ajax를 사용하면 왜 사용자 경험이 향상되는지 이해 안 됨 | 기존 방식은 매번 페이지 전체를 새로고침하여 화면이 깜빡이고 시간이 오래 걸림 | Ajax는 필요한 부분만 업데이트하므로 페이지가 깜빡이지 않고, 빠르게 반응하여 데스크톱 앱처럼 부드러운 사용자 경험 제공 |
| Event Loop가 정확히 언제 작동하는지 헷갈림 | Event Loop의 동작 시점과 조건을 명확히 이해하지 못함 | Event Loop는 Call Stack이 완전히 비어있을 때만 Task Queue의 가장 오래된 작업을 Call Stack으로 옮김. 이를 지속적으로 반복하며 확인함 |