# 2025-12-05 TIL

# ✅ 오늘 한 일
- 프로젝트 기획과 설계 프로세스 학습
- 요구사항 분석 및 아키텍처 설계 방법론 이해
- 라우팅 설계 및 프로젝트 구조 컨벤션 학습
- 알라딘 API 데이터 가공 및 전처리 실습
- Django Q 객체를 활용한 복잡한 쿼리 작성법 습득

# 📚 배운 점
- 프로젝트 시작 전 요구사항 분석이 설계 단계의 정확성과 효율성을 좌우함
- 기능적 요구사항(회원 가입, 페이지네이션)과 비기능적 요구사항(로딩 시간)을 구분하여 정의
- 라우팅 설계 시 URL에서의 중첩된 관계를 표현하는 관점이 중요 (컴포넌트 부모-자식 관계와 구분)
- 카테고리 데이터 47,817개를 7개 그룹으로 병합하여 UX 개선 가능
- 데이터 전처리 시 정규표현식으로 노이즈 제거 및 필요한 텍스트만 추출
- Q 객체를 사용하면 Django ORM에서 복잡한 조건문을 비트 논리 연산자로 간결하게 표현 가능

# 📌 핵심 개념
- **기획(Planning)**: 프로젝트 목표와 전략을 수립하는 과정
- **설계(Design)**: 기획된 목표를 구현하기 위한 구조와 방법을 정의하는 과정
- **요구사항 분석**: 사용자와 이해관계자의 필요를 수집하고 명세화하는 과정
  - 기능적 요구사항: 시스템이 수행해야 할 기능 (예: 이메일 가입, 페이지네이션)
  - 비기능적 요구사항: 성능, 보안 등 품질 요구사항 (예: 로딩 3초 이내)
- **아키텍처 결정**: 유지보수성과 확장성 확보, 팀 역할 분담 명확화
- **라우팅 설계**: Route Tree 구상, 중첩/단일 라우팅 결정, 가드 전략, RESTful URL 설계
- **RESTful API 설계 3요소**
  1. 자원의 식별: URI
  2. 자원의 행위: HTTP Methods
  3. 자원의 표현: JSON 데이터
- **컨벤션**: 네이밍, git commit 메시지 등 일관된 스타일 유지
- **컴포넌트 책임 분리**: View 컴포넌트 vs UI 컴포넌트 구분, Props/Emits 설계
- **데이터 가공 프로세스**: 원본 데이터 → 카테고리 맵핑 → 필요 데이터 추출 → 전처리 → 최종 저장
- **Q 객체**: Django ORM에서 복잡한 조건을 구성하는 도구
  - AND(&), OR(|), NOT(~) 연산자로 조건 조합
- **Field lookups**: QuerySet의 filter(), exclude(), get() 메서드에 사용되는 조건 구성 방법
  - `__contains`, `__startswith`, `__endswith` 등

# 💡 예시 코드

**Git Commit 컨벤션**
```
feat: 새로운 기능 추가
fix: 버그 수정
docs: 문서 수정 (README)
style: 코드 포맷 수정 (코드 동작에 영향 없음)
refactor: 코드 구조 개선
```

**카테고리 그룹 병합 (Python)**
```python
new_group_mapping = {
    1: {"name": "소설/시/희곡", "old_pks": [12]},
    2: {"name": "경제/경영", "old_pks": [3]},
    3: {"name": "자기계발", "old_pks": [9, 19, 23]},
    4: {"name": "인문/교양", "old_pks": [5, 11, 15, 17, 18, 21, 27, 28]},
    5: {"name": "취미/실용", "old_pks": [1, 2, 10, 16]},
    6: {"name": "어린이/청소년", "old_pks": [14, 20, 30, 31]},
    7: {"name": "과학", "old_pks": [6, 33]},
}

final_groups = []
for new_pk, mapping_data in new_group_mapping.items():
    merged_cid_list = []
    for old_pk in mapping_data["old_pks"]:
        for group in new_groups:
            if group["pk"] == old_pk:
                merged_cid_list.extend(group["cid_list"])
                break
    final_groups.append({
        "pk": new_pk,
        "name": mapping_data["name"],
        "cid": merged_cid_list
    })
```

**데이터 추출 - JSON 파일 읽기**
```python
import json

# 입력 파일 경로 설정
input_file = "books_raw.json"
categories_file = "categories.json"

# JSON 파일 읽기
with open(input_file, "r", encoding="utf-8") as f:
    books = json.load(f)

with open(categories_file, "r", encoding="utf-8") as f:
    categories = json.load(f)
```

**데이터 추출 - 카테고리별 도서 추출 준비**
```python
# 카테고리별 추출된 도서 수 추적
category_counts = {category["pk"]: 0 for category in categories}

# 추출된 도서를 저장할 리스트
extracted_books = []
fixture_pk = 1
```

**데이터 추출 - 도서 조회 및 맵핑**
```python
for book in books:
    item = book.get("item", {})
    fields = item[0]
    orig_cat = fields.get("categoryId")
    orig_cat_int = int(orig_cat)
    
    for category in categories:
        cid_list = category.get("cid", [])
        if orig_cat_int in cid_list:
            cat_pk = category.get("pk")
            
            if category_counts.get(cat_pk, 0) < 10:
                fixture_fields = {"category": cat_pk}
                
                keys_to_copy = [
                    "title", "description", "isbn13", 
                    "cover", "publisher", "pubDate", 
                    "author", "customerReviewRank"
                ]
                
                for key in keys_to_copy:
                    if key in fields:
                        if key == "customerReviewRank":
                            fixture_fields["customer_review_rank"] = fields[key]
                        elif key == "pubDate":
                            fixture_fields["pub_date"] = fields[key]
                        elif key == "isbn13":
                            fixture_fields["isbn"] = fields[key]
                        else:
                            fixture_fields[key] = fields[key]
                
                fixture_entry = {
                    "model": "books.book",
                    "pk": fixture_pk,
                    "fields": fixture_fields
                }
                
                extracted_books.append(fixture_entry)
                fixture_pk += 1
                category_counts[cat_pk] += 1
                break
```

**데이터 전처리 - description 노이즈 제거**
```python
import re

for book in books:
    fields = book.get("fields", {})
    
    # description 전처리
    if "description" in fields:
        original_desc = fields["description"]
        # &lt; 제거
        processed_desc = re.sub(r'&lt;', '', original_desc)
        fields["description"] = processed_desc
```

**데이터 전처리 - author 텍스트 추출**
```python
for book in books:
    fields = book.get("fields", {})
    
    # author 전처리: 첫 번째 괄호 '(' 앞까지만 남기기
    if "author" in fields:
        original_author = fields["author"]
        # '(' 이전까지의 텍스트 추출
        match = re.search(r'^(.+?)\(', original_author)
        if match:
            processed_author = match.group(1).strip()
        else:
            processed_author = original_author
        fields["author"] = processed_author
```

**데이터 저장**
```python
output_file = "books.json"

with open(output_file, "w", encoding="utf-8") as f:
    json.dump(extracted_books, f, ensure_ascii=False, indent=4)
```

**Q 객체 - AND 조건**
```python
from django.db.models import Q

def and_query(request):
    articles = Article.objects.filter(
        Q(content__contains='dja') & Q(title__startswith='he')
    )
    serializer = ArticleSerializer(articles, many=True)
    return Response(serializer.data)
```

**Q 객체 - OR 조건**
```python
def or_query(request):
    articles = Article.objects.filter(
        Q(content__contains='dja') | Q(title__startswith='he')
    )
    serializer = ArticleSerializer(articles, many=True)
    return Response(serializer.data)
```

**Q 객체 - NOT 조건**
```python
def not_query(request):
    articles = Article.objects.filter(
        ~Q(title__startswith='he')
    )
    serializer = ArticleSerializer(articles, many=True)
    return Response(serializer.data)
```

**Q 객체 - 복합 조건**
```python
# 내용에 'dja' 포함하지 않고 제목이 'he'로 시작하는 Article 또는
# 제목이 'st'로 시작하는 Article 조회
articles = Article.objects.filter(
    (~Q(content__contains='dja') & Q(title__startswith='he')) | 
    Q(title__startswith='st')
)
```

**Field lookups 예시**
```python
# 내용에 'dja'가 포함된 모든 게시글
Article.objects.filter(content__contains='dja')

# 제목이 'he'로 시작하는 모든 게시글
Article.objects.filter(title__startswith='he')

# 제목이 'ing'로 끝나는 게시글
Article.objects.filter(title__endswith='ing')

# 정확히 일치하는 제목
Article.objects.filter(title__exact='Django')

# 대소문자 구분 없이 일치
Article.objects.filter(title__iexact='django')
```

# 🛠️ 이슈 & 해결
| 🐞 문제 상황 | 🔍 원인 | 💡 해결 방법 |
|--------------|--------|--------------|
| 알라딘 카테고리 47,817개로 필터링 구현 시 UX 저하 | 너무 많은 선택 옵션이 사용자 경험에 부정적 | 1 Depth 기준으로 33개 그룹으로 묶고, 다시 7개 대분류로 병합하여 관리 |
| books_raw.json의 categoryId가 알라딘 원본 CID로 되어있음 | 새로 정의한 7개 그룹 pk와 매칭 필요 | categories.json의 cid 리스트를 순회하며 일치하는 카테고리의 pk로 맵핑 |
| 도서 데이터의 description에 `&lt;` 같은 HTML 엔티티 노이즈 존재 | 원본 API 데이터에 포함된 불필요한 문자 | 정규표현식 `re.sub(r'&lt;', '', original_desc)`로 제거 |
| author 필드에 "한강 (지은이), 이미영 (옮긴이)" 형태로 불필요한 정보 포함 | API에서 제공하는 원본 데이터 형식 | 정규표현식 `re.search(r'^(.+?)\(', original_author)`로 첫 괄호 앞까지만 추출 |
| Django ORM에서 복잡한 조건 (AND, OR, NOT 조합) 표현이 어려움 | 기본 filter() 메서드만으로는 복잡한 논리 구현 한계 | Q 객체와 비트 논리 연산자(&, \|, ~)를 활용하여 조건 조합 |
| ISBN10과 ISBN13 필드가 혼재되어 일관성 없음 | 2007년 이전/이후 도서의 ISBN 표준 차이 | ISBN13을 표준으로 선택하고 키 이름을 'isbn'으로 통일 |
| Fixture 데이터의 필드명이 Django 모델 필드명과 불일치 | API 응답의 camelCase vs Django의 snake_case | 키 매핑 로직 추가: `customerReviewRank` → `customer_review_rank`, `pubDate` → `pub_date` |

