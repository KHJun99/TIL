# 2025-12-01 TIL

# ✅ 오늘 한 일
- Vue.js의 Computed Property, 조건부 렌더링, 리스트 렌더링 학습
- Watchers와 Lifecycle Hooks 개념 이해
- Todo 애플리케이션 구현 실습

# 📚 배운 점
- **computed**는 의존하는 반응형 데이터를 기반으로 계산된 값을 캐싱하여, 불필요한 반복 연산을 방지하고 성능을 향상시킨다
- **v-if**는 조건이 false일 때 DOM에서 요소를 완전히 제거하지만, **v-show**는 CSS display 속성만 변경하여 자주 토글하는 경우 더 효율적이다
- **v-for** 사용 시 반드시 **key** 속성을 함께 제공해야 Vue가 각 항목을 효율적으로 추적할 수 있다
- **watch**는 데이터 변경을 감지하여 비동기 작업이나 side effect를 수행할 때 사용한다
- **Lifecycle Hooks**는 컴포넌트의 생애주기 특정 시점에 로직을 실행할 수 있게 해주며, 반드시 동기적으로 작성해야 한다

# 📌 핵심 개념
- **computed vs methods**: computed는 의존 데이터가 변경될 때만 재계산(캐싱), methods는 호출될 때마다 항상 실행
- **v-if vs v-show**: v-if는 DOM 제거/추가(토글 비용 높음), v-show는 CSS display 전환(초기 렌더링 비용 높음)
- **v-for와 key**: key는 각 항목의 고유 식별자로, 배열 인덱스가 아닌 데이터베이스 ID나 UUID 같은 고유값 사용 권장
- **computed vs watch**: computed는 선언형으로 계산된 값을 반환, watch는 명령형으로 데이터 변경 시 특정 작업 수행

# 💡 예시 코드

```javascript
// computed 사용 예시
const todos = ref([
  { text: 'Vue 실습' },
  { text: '자격증 공부' }
])

const restOfTodos = computed(() => {
  return todos.value.length > 0 ? '아직 남았다' : '퇴근!'
})
```

```html
<!-- v-for와 key 사용 -->
<div v-for="item in items" :key="item.id">
  {{ item.name }}
</div>
```

```javascript
// watch 사용 예시
const count = ref(0)

watch(count, (newValue, oldValue) => {
  console.log(`newValue: ${newValue}, oldValue: ${oldValue}`)
})
```

```javascript
// Lifecycle Hook - onMounted
onMounted(() => {
  console.log('컴포넌트가 DOM에 마운트되었습니다')
})
```

# 🛠️ 이슈 & 해결
| 🐞 문제 상황 | 🔍 원인 | 💡 해결 방법 |
|--------------|--------|--------------|
| v-for와 v-if를 같은 요소에 사용 시 에러 발생 | v-if의 우선순위가 더 높아 v-for 범위의 변수에 접근 불가 | computed로 필터링된 배열을 생성하거나, template 태그로 v-if 위치 조정 |
| computed에서 배열 정렬 시 원본 배열이 변경됨 | reverse(), sort() 등은 원본 배열을 직접 변경하는 메서드 | 스프레드 연산자로 복사본 생성 후 정렬: `[...numbers].reverse()` |